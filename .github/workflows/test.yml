name: test Workflow

on:
  workflow_call:
    inputs:
      image_name:
        required: true
        type: string
        default: ubuntu
      run_platform:
        required: false
        type: string
        default: amd64
      tool_chain:
        required: true
        type: string
        default: gcc-11
      ros_distro:
        required: false
        type: string
        default: humble

jobs:
  test:
    runs-on: ${{ inputs.run_platform }}
    container:
      image: ${{ inputs.image_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get short sha
        id: slug
        run: echo "sha8=$(echo ${GITHUB_SHA} | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: Initialize Environment
        shell: bash
        id: init
        env:
          ROS_DISTRO_INPUT: ${{ inputs.ros_distro }}
        run: |
          # ROS_DISTRO_INPUT is passed from ci.yml matrix (ros_distro field)
          # If not provided, auto-detect from image name as fallback
          if [ -z "$ROS_DISTRO_INPUT" ] || [ "$ROS_DISTRO_INPUT" == "" ]; then
            if [[ "${{ inputs.image_name }}" == *"jazzy"* ]]; then
              ROS_DISTRO_INPUT="jazzy"
            else
              ROS_DISTRO_INPUT="humble"
            fi
          fi
          echo "ROS_DISTRO=$ROS_DISTRO_INPUT" >> $GITHUB_ENV
          echo "Detected ROS distro: $ROS_DISTRO_INPUT"

      - name: check ROS 2
        shell: bash
        run: |
          echo "Using ROS distro: $ROS_DISTRO"
          source /opt/ros/${ROS_DISTRO}/setup.bash
          ros2 --help
          echo "ROS_DISTRO: $ROS_DISTRO"
          echo "ROS_VERSION: $ROS_VERSION"
          echo "ROS_PYTHON_VERSION: $ROS_PYTHON_VERSION"

          # remove ros2-latest.list to avoid the error:
          # W: GPG error: http://packages.ros.org/ros2/ubuntu jammy InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY F42ED6FBAB17C654

          if [ -f /etc/apt/sources.list.d/ros2-latest.list ]; then
            rm /etc/apt/sources.list.d/ros2-latest.list
          fi

      - name: Install dependencies for build
        shell: bash
        run: |
          echo "Installing dependencies for ROS distro: $ROS_DISTRO"
          apt update -y
          
          # Set Python version and dependencies based on ROS distro
          # Humble: Ubuntu 22.04 (Jammy) with Python 3.10
          # Jazzy: Ubuntu 24.04 (Noble) with Python 3.12
          if [ "$ROS_DISTRO" == "jazzy" ]; then
            PYTHON_VERSION="3.12"
            PYTHON_VENV_PKG="python3.12-venv"
            EMPY_VERSION=""  # Use latest empy for Jazzy
          else
            PYTHON_VERSION="3.10"
            PYTHON_VENV_PKG="python3-venv"
            EMPY_VERSION="==3.3.4"  # Use empy 3.3.4 for Humble compatibility
          fi
          
          # Common dependencies for both distros
          COMMON_DEPS="curl wget python3-pip python3-build python3-setuptools python3-wheel make vim libglib2.0-dev libcurl4-openssl-dev zip lcov bc git build-essential autoconf libtool pkg-config doxygen libacl1-dev python3-empy python3-catkin-pkg python3-lark"
          
          # Install Python and dependencies
          apt install python${PYTHON_VERSION} ${PYTHON_VENV_PKG} ${COMMON_DEPS} -y
          
          # Ensure python3 points to the correct version
          if [ "$ROS_DISTRO" == "jazzy" ]; then
            update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.12 1 || true
          fi
          
          # Create virtual environment for Python packages
          python3 -m venv /tmp/venv
          source /tmp/venv/bin/activate
          pip install --upgrade pip
          
          # Install ROS 2 build dependencies with version-specific empy
          pip install catkin_pkg "empy${EMPY_VERSION}" lark-parser numpy
          
          # Install other Python packages
          pip install pyinstaller jinja2 setuptools==74.1.2 wheel pyyaml sphinx sphinx_rtd_theme sphinx-design myst-parser build linkify-it-py sphinx_multiversion

      - name: set up rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: 1.75.0

      - name: download and Use cmake
        shell: bash
        run: |
          source /tmp/venv/bin/activate
          pip install cmake==3.28.0
          cmake --version

      - name: set up toolchain
        shell: bash
        env:
          tool_chain: ${{ inputs.tool_chain }}
        run: |
          if [[ "$tool_chain" =~ gcc-([0-9.]+) ]]; then
              version="${BASH_REMATCH[1]}"
              apt-get update -y
              apt-get install software-properties-common -y
              add-apt-repository ppa:ubuntu-toolchain-r/test -y
              apt-get update -y
              apt-get install gcc-$version g++-$version -y
              echo "Extracted version: $version"
              gcc-$version --version
              g++-$version --version
              echo "CC=$(which gcc-$version)" >> $GITHUB_ENV
              echo "CXX=$(which g++-$version)" >> $GITHUB_ENV
          elif [[ "$tool_chain" =~ clang-([0-9.]+) ]]; then
              apt install lsb-release wget software-properties-common gnupg -y
              version="${BASH_REMATCH[1]}"
              echo $version
              wget https://apt.llvm.org/llvm.sh
              chmod +x llvm.sh
              ./llvm.sh ${version}
              clang-$version --version
              clang++-$version --version
              echo "CC=$(which clang-$version)" >> $GITHUB_ENV
              echo "CXX=$(which clang++-$version)" >> $GITHUB_ENV
          fi

      - name: start test
        shell: bash
        run: |
          echo "Testing with ROS distro: $ROS_DISTRO"
          source /opt/ros/${ROS_DISTRO}/setup.bash
          source /tmp/venv/bin/activate
          ./test.sh

      - name: generate test_coverage.sh
        run: |
            echo "generate /tmp/test_coverage.sh ..."

            cat << EOF >/tmp/test_coverage.sh
            #!/bin/bash

            ret=0

            # 创建一个\$workdir文件夹，用于存放所有的.gcda文件
            workdir='/tmp/gtest_report'

            rm \$workdir -rf

            mkdir -p \$workdir

            default_ignore=(
                "_test.cc"
                "_test.c"
                "_test.cpp"
                "*/build/_deps/*"
            )

            default_test_cov_ignore=(
              "*/include/*"
              "*/build/_deps/*"
              \${TEST_COVERAGE_IGNORE[@]}
            )

            # 查找同时存在 *.gcda 和 *.gcno 文件的文件
            gcda_files=\$(find ./build -type f -name "*.gcda")
            for gcda_file in \$gcda_files; do
                # 如果匹配了 \$default_ignore 中的文件，则跳过
                for ignore in \${default_ignore[@]}; do
                    # 使用正则表达式匹配
                    if [[ \$gcda_file =~ \$ignore ]]; then
                        echo "ignore \$gcda_file"
                        continue 2
                    fi
                done

                gcno_file="\${gcda_file%.gcda}.gcno"
                if [ -f "\$gcno_file" ]; then
                    cp "\$gcda_file" "\$workdir"
                    cp "\$gcno_file" "\$workdir"
                fi
            done

            cd \$workdir

            # 如果当前目录下没有gcda文件，则直接退出，不需要进行测试覆盖率检查
            if [ -z "\$(find . -name "*.gcda")" ]; then
                echo "no gcda files, not need to test coverage"
                exit 0
            fi

            # 使用 gcov 来生成覆盖率数据
            gcov *.gcno >/dev/null 2>&1

            # 生成报告
            lcov -c -d . -o coverage.info >/dev/null 2>&1

            # 过滤掉不需要的信息

            for ignore in \${default_test_cov_ignore[@]}; do
                lcov --remove coverage.info "\$ignore" -o coverage.info >/dev/null 2>&1
            done

            # 列出测试覆盖率
            lcov -l coverage.info

            # 判断整体覆盖率是否达标
            test_coverage=\$(lcov -l coverage.info | grep "Total:" | sed 's/|/| /g' | awk '{print \$2}' | awk -F '%' '{print \$1}')
            # if error to get test_coverage
            if [ -z "\$test_coverage" ];
            then
                echo "no test coverage, skip"
                exit 0
            fi

            # 生成html报告
            test_coverage_dir=\${GITHUB_WORKSPACE}/${{ github.repository_owner }}/${{ github.event.repository.name }}/${{ github.ref_name }}/${{ steps.slug.outputs.sha8 }}
            mkdir -p \$test_coverage_dir

            genhtml coverage.info -o \$test_coverage_dir >/dev/null 2>&1

            cd \${GITHUB_WORKSPACE}
            zip -r ${{ steps.slug.outputs.sha8 }}.zip ${{ github.repository_owner }}/${{ github.event.repository.name }}/${{ github.ref_name }}/${{ steps.slug.outputs.sha8 }}

            # 如果 TEST_COVERAGE_THRESHOLD 变量为空，则默认为 0
            if [ -z "\$TEST_COVERAGE_THRESHOLD" ]; then
                TEST_COVERAGE_THRESHOLD=0
            fi

            echo "test coverage: \$test_coverage"

            # 将TEST_COVERAGE_THRESHOLD转换为数字，防止出现字符串比较的情况
            test_coverage_threshold=\$(echo \$TEST_COVERAGE_THRESHOLD | tr -d '"')

            #比较两个数的大小，一个是小数，一个是整数
            if [ \$(echo "\$test_coverage >= \$test_coverage_threshold" | bc) -eq 1 ]; then
                echo "test coverage is greater than \$test_coverage_threshold"
            else
                echo "test coverage is less than \$test_coverage_threshold"
                ret=1
            fi

            exit \$ret

            EOF

      - name: run test_coverage.sh
        shell: bash
        run: |
          chmod +x /tmp/test_coverage.sh
          echo "test_coverage.sh is authorized"
          bash /tmp/test_coverage.sh
          ls -lh .

      - name: upload testcoverage report
        uses: actions/upload-artifact@v4
        if: inputs.tool_chain == 'gcc-11' && inputs.run_platform == 'ubuntu-22.04'
        with:
          name: testcoverage_report
          path: |
              ${{ steps.slug.outputs.sha8 }}.zip
          retention-days: 3