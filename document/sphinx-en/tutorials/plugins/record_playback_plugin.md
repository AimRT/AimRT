# Recording Playback Plugin

## Related Links

Protocol Files:
- {{ '[record_playback.proto]({}/src/protocols/plugins/record_playback_plugin/record_playback.proto)'.format(code_site_root_path_url) }}

Reference Examples:
- {{ '[record_playback_plugin]({}/src/examples/plugins/record_playback_plugin)'.format(code_site_root_path_url) }}## Plugin Overview

**record_playback_plugin** is used for recording and playing back Channel data. The plugin supports loading independent type_support_pkg and offers various working modes such as immediate mode and signal-triggered mode.

When in use, the plugin registers one or more Channel Subscribers or Publishers based on configuration, subscribing to data stored in a database or reading data from the database for publishing. Additionally, the plugin registers an RPC defined by the protobuf protocol, providing some interfaces for signal-triggered mode. Please note that **record_playback_plugin** does not provide any communication backend, so the signal-triggered functionality generally needs to be used in conjunction with the RPC backend of other communication plugins, such as the HTTP RPC backend in [net_plugin](./net_plugin.md).

The plugin configuration items are as follows:

| Node                              | Type          | Optional | Default  | Purpose |
| ----                              | ----          | ----     | ----     | ----    |
| service_name                      | string        | Optional | ""       | RPC Service Name. If left blank, the default value generated by the protocol is used |
| type_support_pkgs                 | array         | Optional | []       | type_support package configuration |
| type_support_pkgs[i].path         | string        | Required | ""       | Path of the type_support package |
| timer_executor                    | string        | Required in recording mode | []       | Executor used for recording, which must support time schedule |
| record_actions                    | array         | Optional | []       | Recording action configuration |
| record_actions[i].name            | string        | Required | ""       | Action name |
| record_actions[i].options         | map           | Required | -        | Action options |
| record_actions[i].options.bag_path        | string        | Required | ""       | Path to store the recording package |
| record_actions[i].options.mode            | string        | Required | ""       | Recording mode (case-insensitive): immediate mode: "imd", signal-triggered mode: "signal" |
| record_actions[i].options.max_preparation_duration_s  | unsigned int  | Optional | 0        | Maximum data preparation time in advance, only effective in signal mode |
| record_actions[i].options.executor        | string        | Required | ""       | Executor used for recording, which must be thread-safe |
| record_actions[i].options.storage_policy  | map           | Optional | -        | Storage policy for recording packages |
| record_actions[i].options.storage_policy.max_bag_size_m  | unsigned int  | Optional | 2048     | Maximum size of the recording package in MB |
| record_actions[i].options.storage_policy.max_bag_num     | unsigned int  | Optional | 0        | Maximum number of recording packages. The oldest package will be deleted when exceeded. 0 means unlimited |
| record_actions[i].options.storage_policy.msg_write_interval     | unsigned int  | Optional | 1000     | Force disk write every specified number of messages |
| record_actions[i].options.storage_policy.msg_write_interval_time     | unsigned int  | Optional | 1000     | Force disk write at specified time intervals (default unit: ms) |
| record_actions[i].options.storage_policy.compression_mode | string        | Optional | "zstd"   | Compression mode (case-insensitive, only valid in mcap mode). Available options: "none", "lz4", "zstd" |
| record_actions[i].options.storage_policy.compression_level | string        | Optional | "default" | Compression level (case-insensitive, only valid in mcap mode). Available options: "fastest", "fast", "default", "slow", "slowest" |
| record_actions[i].options.extra_attributes                | map     | Optional | []        | Additional attribute list attached during recording |
| record_actions[i].options.topic_meta_list | array        | Optional | []        | Topics and types to be recorded |
| record_actions[i].options.topic_meta_list[j].topic_name   | string        | Required | ""        | Topic to be recorded |
| record_actions[i].options.topic_meta_list[j].msg_type     | string        | Required | ""        | Message type to be recorded |
| record_actions[i].options.topic_meta_list[j].serialization_type     | string        | Optional | ""        | Serialization type used during recording. If left blank, the default serialization type of the message type is used |
| playback_actions                  | array         | Optional | []        | Playback action configuration |
| playback_actions[i].name          | string        | Required | ""        | Action name |
| playback_actions[i].options       | map           | Required | -         | Action options |
| playback_actions[i].options.bag_path      | string        | Required | ""        | Path of the recording package |
| playback_actions[i].options.mode          | string        | Required | ""        | Playback mode (case-insensitive): immediate mode: "imd", signal-triggered mode: "signal" |
| playback_actions[i].options.executor      | string        | Required | ""        | Executor used for playback, which must support time schedule |
| playback_actions[i].options.skip_duration_s   | unsigned int  | Optional | 0         | Time to skip during playback (only effective in imd mode) |
| playback_actions[i].options.play_duration_s   | unsigned int  | Optional | 0         | Playback duration (only effective in imd mode). 0 means playing the entire package |
| playback_actions[i].options.topic_meta_list   | array         | Optional | []        | Topics and types to be played back, which must exist in the recording package. If left blank, all topics are played by default || playback_actions[i].options.topic_meta_list[j].topic_name   | string        | Required  | ""        | Topic to be played |
| playback_actions[i].options.topic_meta_list[j].msg_type     | string        | Required  | ""        | Message type to be played |

Please note that in the **record_playback_plugin**, recording/playback actions are managed in `action` units. Each recording/playback `action` can have its own mode, thread, package path parameters, and can be triggered independently. During usage, you can allocate appropriate resources to each action based on the actual data size and frequency.

The `record_playback_plugin` supports saving data in `mcap` format, with configurable compression modes and levels. For reference, see [mcap default storage parameters](https://github.com/foxglove/mcap/blob/releases/cpp/v1.4.0/cpp/mcap/include/mcap/writer.hpp). To be compatible with `plotjuggler 3.9.1` visualization, when saving data in `mcap` format, both `publish time` and `log time` will be set, with values equal to `log time`.

Here is a simple example configuration for signal-triggered recording functionality:
```yaml
aimrt:
  plugin:
    plugins:
      - name: net_plugin
        path: ./libaimrt_net_plugin.so
        options:
          thread_num: 4
          http_options:
            listen_ip: 127.0.0.1
            listen_port: 50080
      - name: record_playback_plugin
        path: ./libaimrt_record_playback_plugin.so
        options:
          timer_executor: storage_executor  # require time schedule!
          type_support_pkgs:
            - path: ./libexample_pb_ts.so
          record_actions:
            - name: my_signal_record
              options:
                bag_path: ./bag
                mode: signal # imd/signal
                max_preparation_duration_s: 10 # Effective only in signal mode
                executor: record_thread # require thread safe!
                storage_policy:
                  max_bag_size_m: 2048
                  msg_write_interval: 1000        # message count period
                  msg_write_interval_time: 1000   # ms
                  compression_mode: zstd     # comression mode
                  compression_level: default   # comression level
                extra_attributes:
                  platform: arm64
                  os: ubuntu-22.04
                topic_meta_list:
                  - topic_name: test_topic
                    msg_type: pb:aimrt.protocols.example.ExampleEventMsg
                    serialization_type: pb # optional
  executor:
    executors:
      - name: record_thread
        type: simple_thread
      - name: storage_executor
        type: asio_thread
        options:
          thread_num: 2
  channel:
    # ...
  rpc:
    backends:
      - type: http
    servers_options:
      - func_name: "(pb:/aimrt.protocols.record_playback_plugin.*)"
        enable_backends: [http]
```
## RecordPlaybackService

In {{ '[record_playback.proto]({}/src/protocols/plugins/record_playback_plugin/record_playback.proto)'.format(code_site_root_path_url) }}, a `RecordPlaybackService` is defined, providing the following interfaces:
- **StartRecord**: Start recording;
- **StopRecord**: Stop recording;
- **StartPlayback**: Start playback;
- **StopPlayback**: Stop playback;
- **UpdateMetadata**: Update the `ext_attributes` field of the recording package;

### StartRecord

The `StartRecord` interface is used to initiate a record action in signal mode. Its interface definition is as follows:
```proto
message StartRecordReq {
  string action_name = 1;
  uint32 preparation_duration_s = 2;
  uint32 record_duration_s = 3;  // record forever if value is 0
}

message CommonRsp {
  uint32 code = 1;
  string msg = 2;
}

service RecordPlaybackService {
  // ...
  rpc StartRecord(StartRecordReq) returns (CommonRsp);
  // ...
}
```

Developers can specify the following parameters in the request package `StartRecordReq`:
- `action_name`: The name of the record action to start;
- `preparation_duration_s`: The duration to record backward from the time the request is received, in seconds. This value cannot exceed the `max_preparation_duration_s` configured for the action;
- `record_duration_s`: The duration of the recording, in seconds. If set to 0, recording will continue indefinitely until the process stops;

Here is an example of calling this interface via HTTP using the curl tool, based on the http RPC backend in **net_plugin**:
```shell
data='{
    "action_name": "my_signal_record",
    "preparation_duration_s": 5,
    "record_duration_s": 10
}'

curl -i \
    -H 'content-type:application/json' \
    -X POST 'http://127.0.0.1:50080/rpc/aimrt.protocols.record_playback_plugin.RecordPlaybackService/StartRecord' \
    -d "$data"
```

This example command starts a record action named `my_signal_record`, recording 5 seconds of data backward and continuing for 10 seconds. If the call is successful, the command returns the following:
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19

{"code":0,"msg":""}
```

### StopRecord

The `StopRecord` interface is used to stop a running signal mode record action. Its interface definition is as follows:
```proto
message StopRecordReq {
  string action_name = 1;
}

message CommonRsp {
  uint32 code = 1;
  string msg = 2;
}

service RecordPlaybackService {
  // ...
  rpc StopRecord(StopRecordReq) returns (CommonRsp);
  // ...
}
```

Developers can specify the following parameter in the request package `StartRecordReq`:
- `action_name`: The name of the record action to stop;

Here is an example of calling this interface via HTTP using the curl tool, based on the http RPC backend in **net_plugin**:
```shell
data='{
    "action_name": "my_signal_record"
}'

curl -i \
    -H 'content-type:application/json' \
    -X POST 'http://127.0.0.1:50080/rpc/aimrt.protocols.record_playback_plugin.RecordPlaybackService/StopRecord' \
    -d "$data"
```

This example command stops the record action named `my_signal_record`. If the call is successful, the command returns the following:
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19

{"code":0,"msg":""}
```

### StartPlayback

The `StartPlayback` interface is used to initiate a playback action in signal mode. Its interface definition is as follows:
```proto
message StartPlaybackReq {
  string action_name = 1;
  uint32 skip_duration_s = 2;
  uint32 play_duration_s = 3;  // playback to end if value is 0
}

message CommonRsp {
  uint32 code = 1;
  string msg = 2;
}

service RecordPlaybackService {
  // ...
  rpc StartPlayback(StartPlaybackReq) returns (CommonRsp);
  // ...
}
```

Developers can specify the following parameters in the request package `StartPlaybackReq`:
- `action_name`: The name of the playback action to start;
- `skip_duration_s`: The duration to skip, in seconds;
- `play_duration_s`: The duration of playback, in seconds;

Here is an example of calling this interface via HTTP using the curl tool, based on the http RPC backend in **net_plugin**:
```shell
data='{
    "action_name": "my_signal_playback",
    "skip_duration_s": 5,
    "play_duration_s": 10
}'

curl -i \
    -H 'content-type:application/json' \
    -X POST 'http://127.0.0.1:50080/rpc/aimrt.protocols.record_playback_plugin.RecordPlaybackService/StartPlayback' \
    -d "$data"
```

This example command starts a playback action named `my_signal_playback`, skipping 5 seconds of data and playing for 10 seconds. If the call is successful, the command returns the following:
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19

{"code":0,"msg":""}
```
### StopPlayback

The `StopPlayback` interface is used to stop a currently running signal-mode playback action. Its interface definition is as follows:

```proto
message StopPlaybackReq {
  string action_name = 1;
}

message CommonRsp {
  uint32 code = 1;
  string msg = 2;
}

service RecordPlaybackService {
  // ...
  rpc StopPlayback(StopPlaybackReq) returns (CommonRsp);
  // ...
}
```

Developers can fill in the following parameters in the request packet `StopPlaybackReq`:
- `action_name`: The name of the playback action to be stopped;

Here is an example of calling this interface via HTTP using the curl tool based on the http RPC backend in **net_plugin**:

```shell
data='{
    "action_name": "my_signal_playback"
}'

curl -i \
    -H 'content-type:application/json' \
    -X POST 'http://127.0.0.1:50080/rpc/aimrt.protocols.record_playback_plugin.RecordPlaybackService/StopPlayback' \
    -d "$data"
```

This example command can stop the playback action named `my_signal_playback`. If the call is successful, the command returns the following value:

```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19

{"code":0,"msg":""}
```

### UpdateMetadata

The `UpdateMetadata` interface is used to update custom metadata (extra attributes) associated with a specified record action. This interface is not restricted by recording mode, and its interface definition is as follows:

```proto
message UpdateMetadataReq {
  string action_name = 1;
  map<string, string> kv_pairs = 2;
}

service RecordPlaybackService {
  // ...
  rpc UpdateMetadata(UpdateMetadataReq) returns (CommonRsp);
  // ...
}
```

Developers can fill in the following parameters in the request packet `UpdateMetadataReq`:
- `action_name`: The name of the record action to be updated;
- `kv_pairs`: A map containing key-value pairs of metadata to be updated or added.
  - `key`: The name of the metadata. Note: When the Key is an empty string, the key-value pair will be ignored; when the key is duplicated, only the last updated value will be retained.
  - `value`: The value of the metadata. The server-side implementation of this interface will attempt to parse each value string as YAML format:
    * If the parsing succeeds, the value string is considered valid YAML data. The parsed YAML structure (which could be a Map, List, or simple scalar values like strings, numbers, booleans, etc.) will be stored as the metadata item. This means you can pass in a serialized complex YAML structure string, which will be stored as the corresponding structured data.
    * If the parsing fails, the system will catch the parsing exception and store the original value string itself as a plain text string for the metadata item.

Here is an example of calling this interface via HTTP using the curl tool based on the http RPC backend in **net_plugin**:

```shell
data='{
    "action_name": "my_signal_record",
    "kv_pairs":{ "key": "timestamp: '2023-10-25T12:34:56.789Z'\nposition:\n  x: 1.2\n  y: 3.4\n  z: 0.0\norientation:\n  roll: 0.0\n  pitch: 0.0\n  yaw: 1.57\nsensor_temperature: 25.5C\nsensor_distance_front: 1.8m\nbattery_voltage: 12.4V\nbattery_level: 85%\nmotor_speed_left: 100rpm\nmotor_speed_right: 102rpm\nstatus: active\nmode: autonomous\nlog_message: Navigation started."}
}'
curl -i \
    -H 'content-type:application/json' \
    -X POST 'http://127.0.0.1:50080/rpc/aimrt.protocols.record_playback_plugin.RecordPlaybackService/UpdateMetadata' \
    -d "$data"

```

This example command can update the metadata of the record action named `my_signal_record`. If the call is successful, the command returns the following value:

```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 19

{"code":0,"msg":""}
```